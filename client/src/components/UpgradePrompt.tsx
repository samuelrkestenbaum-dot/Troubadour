import { useEffect, useMemo, useState } from "react";
import { useLocation } from "wouter";
import { X, Sparkles, Zap, Crown, ArrowRight, Music } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { trackEvent } from "@/lib/analytics";

interface UpgradePromptProps {
  /** The error message from the FORBIDDEN response */
  message: string;
  /** Called when user dismisses the prompt */
  onDismiss: () => void;
  /** Optional: which feature triggered the limit */
  trigger?: "review" | "feature" | "upload";
}

const TIER_BENEFITS = [
  {
    tier: "Artist",
    price: "$9.99/mo",
    color: "from-blue-500 to-indigo-600",
    icon: Music,
    highlights: [
      "10 AI reviews per month",
      "All Action Modes (Mix Check, Hook Test, etc.)",
      "Skill Progression tracking",
      "Competitive Benchmarking",
    ],
  },
  {
    tier: "Pro",
    price: "$24.99/mo",
    color: "from-amber-500 to-orange-600",
    icon: Crown,
    highlights: [
      "Unlimited AI reviews",
      "Priority processing (2x faster)",
      "Release Readiness scoring",
      "Artist DNA profiling",
      "Full Intelligence Suite",
    ],
  },
];

// ── A/B Copy Variants (generated by Claude 4.5) ──────────────────────
// Each variant uses a different psychological approach to conversion.
// PostHog tracks which variant was shown and whether the user clicked through.
type CopySet = { headline: string; subtitle: string; cta: string };
type VariantCopy = {
  name: string;
  review: CopySet;
  feature: CopySet;
  upload: CopySet;
};

const COPY_VARIANTS: Record<string, VariantCopy> = {
  A: {
    name: "loss_aversion",
    review: {
      headline: "Your Music Deserves More Feedback",
      subtitle: "Your monthly review is done, but your potential isn't. Without more feedback, you're leaving growth on the table.",
      cta: "Unlock More Reviews",
    },
    feature: {
      headline: "You're Missing Key Insights",
      subtitle: "This powerful feature could transform your sound, but it's currently out of reach. Don't let your tracks stay stuck.",
      cta: "Access All Features",
    },
    upload: {
      headline: "Don't Let Limits Hold You Back",
      subtitle: "Your creative flow shouldn't be capped. Every track you don't upload is a missed opportunity for feedback and improvement.",
      cta: "Upload More Tracks",
    },
  },
  B: {
    name: "social_proof",
    review: {
      headline: "Artists Are Leveling Up. Are You?",
      subtitle: "The best in the game aren't waiting. They're getting constant feedback to refine their sound and dominate their genre.",
      cta: "Join the Pros",
    },
    feature: {
      headline: "What Do Top Artists Know?",
      subtitle: "Successful musicians use these tools to sharpen their edge. Don't get left behind; equip yourself with their secrets.",
      cta: "See How They Grow",
    },
    upload: {
      headline: "Serious Artists Upload More. Period.",
      subtitle: "The most successful creators are constantly testing and refining. Unlimited uploads mean unlimited chances to shine.",
      cta: "Upload Like a Pro",
    },
  },
  C: {
    name: "curiosity_gap",
    review: {
      headline: "What Else Did Our AI Find?",
      subtitle: "Your last review was just the beginning. Imagine the deeper insights waiting for your next track.",
      cta: "Reveal More Insights",
    },
    feature: {
      headline: "Curious What This Can Do?",
      subtitle: "This feature holds the key to unlocking a new dimension in your music. Don't you want to know what it is?",
      cta: "Discover the Power",
    },
    upload: {
      headline: "What Could Your Next Track Reveal?",
      subtitle: "Every new upload is a chance for our AI to uncover something game-changing about your sound.",
      cta: "Uncover New Potential",
    },
  },
  D: {
    name: "value_proposition",
    review: {
      headline: "More Reviews = Better Music. Simple.",
      subtitle: "Stop guessing. More AI-powered feedback means faster growth and tracks that truly connect with your audience.",
      cta: "Upgrade Your Feedback",
    },
    feature: {
      headline: "Unlock Tools That Transform Tracks",
      subtitle: "Gain access to powerful features designed to refine your sound, track your progress, and stand out.",
      cta: "Get Full Access",
    },
    upload: {
      headline: "Unlimited Uploads, Unlimited Growth",
      subtitle: "Don't let limits hold you back. Upload every idea, get feedback, and accelerate your musical journey.",
      cta: "Go Unlimited Now",
    },
  },
};

const VARIANT_KEYS = Object.keys(COPY_VARIANTS);
const AB_STORAGE_KEY = "troubadour_upgrade_variant";

/**
 * Deterministically assign a variant to the user.
 * Persists in localStorage so the same user always sees the same variant.
 */
function getAssignedVariant(): string {
  try {
    const stored = localStorage.getItem(AB_STORAGE_KEY);
    if (stored && VARIANT_KEYS.includes(stored)) return stored;
  } catch { /* localStorage unavailable */ }

  const assigned = VARIANT_KEYS[Math.floor(Math.random() * VARIANT_KEYS.length)];
  try {
    localStorage.setItem(AB_STORAGE_KEY, assigned);
  } catch { /* ignore */ }
  return assigned;
}

export function UpgradePrompt({ message, onDismiss, trigger = "review" }: UpgradePromptProps) {
  const [, navigate] = useLocation();
  const [isVisible, setIsVisible] = useState(true);

  // Assign variant once per user session
  const variantKey = useMemo(() => getAssignedVariant(), []);
  const variant = COPY_VARIANTS[variantKey];
  const copy = variant[trigger];

  // Track impression on mount
  useEffect(() => {
    trackEvent("upgrade_prompt_shown", {
      variant: variantKey,
      variant_name: variant.name,
      trigger,
      headline: copy.headline,
    });
  }, [variantKey, variant.name, trigger, copy.headline]);

  if (!isVisible) return null;

  const handleDismiss = () => {
    trackEvent("upgrade_prompt_dismissed", {
      variant: variantKey,
      variant_name: variant.name,
      trigger,
    });
    setIsVisible(false);
    onDismiss();
  };

  const handleCTAClick = (source: string) => {
    trackEvent("upgrade_prompt_clicked", {
      variant: variantKey,
      variant_name: variant.name,
      trigger,
      source,
    });
    handleDismiss();
    navigate("/pricing");
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm animate-in fade-in duration-200">
      <div className="relative w-full max-w-lg mx-4 bg-card border border-border/50 rounded-2xl shadow-2xl overflow-hidden">
        {/* Gradient accent bar */}
        <div className="h-1.5 bg-gradient-to-r from-blue-500 via-purple-500 to-amber-500" />

        {/* Close button */}
        <button
          onClick={handleDismiss}
          className="absolute top-4 right-4 p-1.5 rounded-full hover:bg-muted/50 transition-colors text-muted-foreground hover:text-foreground"
        >
          <X className="h-4 w-4" />
        </button>

        {/* Header */}
        <div className="px-6 pt-6 pb-4">
          <div className="flex items-center gap-2 mb-2">
            <div className="p-2 rounded-lg bg-primary/10">
              <Sparkles className="h-5 w-5 text-primary" />
            </div>
            <Badge variant="outline" className="text-xs border-primary/30 text-primary">
              Upgrade Available
            </Badge>
          </div>
          <h2 className="text-xl font-bold tracking-tight">
            {copy.headline}
          </h2>
          <p className="text-sm text-muted-foreground mt-1">
            {copy.subtitle}
          </p>
        </div>

        {/* Tier cards */}
        <div className="px-6 pb-4 grid grid-cols-2 gap-3">
          {TIER_BENEFITS.map((tier) => (
            <button
              key={tier.tier}
              onClick={() => handleCTAClick(`tier_card_${tier.tier.toLowerCase()}`)}
              className="group text-left p-4 rounded-xl border border-border/50 hover:border-primary/40 transition-all hover:shadow-lg hover:shadow-primary/5 bg-muted/20 hover:bg-muted/40"
            >
              <div className="flex items-center gap-2 mb-3">
                <div className={`p-1.5 rounded-lg bg-gradient-to-br ${tier.color}`}>
                  <tier.icon className="h-3.5 w-3.5 text-white" />
                </div>
                <div>
                  <span className="text-sm font-semibold">{tier.tier}</span>
                  <span className="text-xs text-muted-foreground ml-1.5">{tier.price}</span>
                </div>
              </div>
              <ul className="space-y-1.5">
                {tier.highlights.map((h, i) => (
                  <li key={i} className="text-xs text-muted-foreground flex items-start gap-1.5">
                    <Zap className="h-3 w-3 text-primary mt-0.5 shrink-0" />
                    <span>{h}</span>
                  </li>
                ))}
              </ul>
              <div className="mt-3 flex items-center gap-1 text-xs font-medium text-primary opacity-0 group-hover:opacity-100 transition-opacity">
                View plan <ArrowRight className="h-3 w-3" />
              </div>
            </button>
          ))}
        </div>

        {/* Bottom CTA */}
        <div className="px-6 pb-6 flex items-center justify-between gap-3">
          <button
            onClick={handleDismiss}
            className="text-xs text-muted-foreground hover:text-foreground transition-colors"
          >
            Maybe later
          </button>
          <Button
            onClick={() => handleCTAClick("main_cta")}
            className="gap-2"
          >
            <Crown className="h-4 w-4" />
            {copy.cta}
          </Button>
        </div>
      </div>
    </div>
  );
}

/**
 * Hook to manage upgrade prompt state.
 * Usage:
 *   const { showUpgrade, upgradeProps } = useUpgradePrompt();
 *   // In mutation onError:
 *   if (err.data?.code === "FORBIDDEN") showUpgrade(err.message, "review");
 *   // In JSX:
 *   {upgradeProps && <UpgradePrompt {...upgradeProps} />}
 */
export function useUpgradePrompt() {
  const [upgradeState, setUpgradeState] = useState<{
    message: string;
    trigger: "review" | "feature" | "upload";
  } | null>(null);

  const showUpgrade = (message: string, trigger: "review" | "feature" | "upload" = "review") => {
    setUpgradeState({ message, trigger });
  };

  const upgradeProps = upgradeState
    ? {
        message: upgradeState.message,
        trigger: upgradeState.trigger,
        onDismiss: () => setUpgradeState(null),
      }
    : null;

  return { showUpgrade, upgradeProps };
}
